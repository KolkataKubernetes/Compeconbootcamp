# Problem 1

    ##Answer to hw 1

function factorial2(n)
    prod::Float64 = 1
    x::Vector{Float64} = collect(range(1,length = n,stop = n))
    for i in x
        prod *= i
    end
    return prod
end

    
factorial2(5)

# Problem 2

## Scratch

coeff::Vector{Float64} = [1,2,3,4,5]

sum = 0
x = 1

for (i,a) in enumerate(coeff)
    sum += a*x^i
    println(sum)
end

##Problem 2 answer

function p(x,coeff)

    sum = 0

    for (i,a) in enumerate(coeff)
        sum += a*x^i
    end
    return sum
end

p(1,coeff)

# Problem 3




# Problem 4

    ##Estimation solution

using Distributions #for rand(norm)

#Preliminary; Create OLS estimator

function OLS(Y,X)
    β = inv(X'*X)*(X'*Y)
    return β
end

#Create function that takes sample size (N) and simulation size (M) as args: OLS_sim(M,N)

function OLS_sim(N::Int64,M::Int64)
    #Declare true coefficient values
    a = .1
    b = .2
    c = .5
    d = 1
    σ = .1 

    #Create OLS output array
    OLS_vec = zeros(4, M) #4 is hard coded to represent the number of non-sigma coefficients
    Y_vec = zeros(M)
    #Create x1, x2
    x1 = rand(Normal(0,1),N)
    x2 = rand(Normal(0,1),N)
    X = hcat(x1, x1.^2, x2, ones(N))
    #Next,  simulate ω and find the true value of Y 'm' times,b 
    for i in 1:M
        ω = rand(Normal(0,1),N)
            ## Declare true Y
        Y = a.*x1 + (b.*x1.^2) + c.*x2 .+d + σ.*ω

        #Estimate OLS 
        OLS_vec[:,i] = OLS(Y,X)


    end
    
    return OLS_vec
end

OLS_estimates = OLS_sim(50,200)



#Plot results
using Distributions, Plots

histogram([OLS_estimates[1,:] OLS_estimates[2,:] OLS_estimates[3,:] OLS_estimates[4,:]], 
label = ["a" "b" "c" "d"])

# Problem 5

#First, I want to create a function that returns the "First Passage" parameter
function fp_time(α::Float64,σ::Float64,t::Int64, x_beg::Float64)
    ##a) create the ARIMA process with x_vec output
    #Create xvec, which contains the values of x generated by the ARIMA process
    x_vec = zeros(t)
x_vec[1] = x_beg
    for i in 2:t
        #Define error term
        ϵ = rand(Normal(0,1))
        x_vec[i] = α*x_vec[i-1] + σ*ϵ
    end


    ##b) find the earliest incidence of α >= a member of x_vec.
    fp_indices = findall(<=(α),x_vec[2:100])
    #fp_indices .+= 1 #Re-adjusting index to account for removal of initial '1' value

    #fp_indices[1] naturally gives the lowest index. But sometimes, we'll return 
    if size(fp_indices) == (0,)
        return t
    else
        return fp_indices[1]
    end

end
fp_index = fp_time(1.0,.2,200,1.0)

size(fp_index)

#= 
We want to simulate the first passage parameter 100 times, for a tmax = 200. We are going to let parameter alpha vary, but the remaining parameters should default.

I should look at Zach O's code to use default parameter values.
=#

function fp_sim(n::Int64,t::Int64,α::Float64)
    simvec = zeros(n)
    for i in 1:n
       simvec[i] = fp_time(α,.2,t,1.0)
    end

    return simvec
end


#α = .8
histogram(fp_sim(100,200,.8), label = "α = .8")
#α = 1
histogram(fp_sim(100,200,1.0), label = "α = 1")
#α = 1.2
histogram(fp_sim(100,200,1.2), bins = range(0,210, length = 21), label = "α = 1.2")



using Distributions, Plots

function simulate_walk(n::Int64, α::Float64, σ::Float64, t_max::Int64)
    first_times = zeros(n)

    for i = 1:n #loop over simulations
        cross_yet = false #we want to keep track of whether we have crossed 0 yet - once we do, we want to be able to keep track of this. We start out with cross_yet=false and only update it if we cross
        x_now = 1
        for t = 1:t_max
            x_next = α * x_now + σ * rand(Normal())
            if x_next<=α #first crossing
                first_times[i] = t
                cross_yet = true #keep track of whether we crossed 0 in this iteration. This will be used to check if we ever crossed
                break #we can safely stop iterating once we reach the first value less than or equal to zero. We do this using the break command. This can save on a bunch of iterations (especially for alpha=0.8)
            end
            x_now = x_next
        end
        if ! cross_yet #if we never crossed in the first 200 iterations, set the first passage time equal to t_max
            first_times[i] = t_max
        end
    end
    first_times #return
end

#0.8
temp = simulate_walk(100, 0.8, 0.2, 200)
histogram(temp)
#to save, use the savefig command 
#1.0
temp = simulate_walk(100, 1.0, 0.2, 200)
histogram(temp)

#1.2
temp = simulate_walk(100, 1.2, 0.2, 200)
histogram(temp)